# Chapter 1 Exercises

## 1.6

When attempting to use the `new-if` procedure, Alyssa will run into an infinite recursive call.

To recap, the `new-if` procedure is defined as follows:

```
(define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
        (else else-clause)))
```

and the `sqrt-iter` procedure is defined like so:

```
(define (sqrt-iter guess x)
    (new-if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
```

The reason this `new-if` function results in infinite recursion is due to the evaluation implementation of the interpreter, which
will evaluate all parameters before passing them to a procedure, with the exception of the built-in `if` procedure, which is a special-form
procedure and is built to have its predicate evaluated first, and then one of its branches evaluated after, depending on the value of the predicate.

## 1.7

recap:

```
(define init-guess 1.0)

(define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
```

a) The `good-enough?` test will not be very effective for finding the square roots of very small numbers.

Our test will not be very effective for computing square roots of very small numbers because our tolerance is not very precise. 
The tolerance is currently hard-coded to be 0.001, which is fine when working with larger numbers, but when working with numbers less than 1 this tolerance
is quite large.

For instance, if we attempt to compute the square root of 0.0000001 our program returns 0.03125 while the actual square root is closer to 0.0003162. 

b) Also, in real computers, arithmetic operations are almost always performed with limited precision. This makes our tests inadequate for very large numbers.

## 1.8

Newton's approximation function for cube-root: `(x/y^2 + 2y) / 3`.

```
(define (cube-root x)
    (define (cube-root-iter guess x)
        (if (good-enough? guess x)
            guess
            (cube-root-iter (improve guess x) x)))
    (define (good-enough? guess x)
        (< (abs (- (cube guess) x)) 0.001))
    (define (improve guess x)
        (/ (+ (/ x (square guess)) (* 2 guess)) 3))
    (define init-guess 1.0)
    (cube-root-iter init-guess x))
```

## 1.9

Given the following two procedures, use the substitution model to illustrate the process generated by each in evaluating (+ 4 5). Are these processe iterative or recursive?

```
(define (inc x)
    (+ x 1))

(define (dec x)
    (- x 1))
```


1. Given the following procedure,

```
(define (+ a b)
    (if (= a 0)
        b
        (inc (+ (dec a) b))))
```

evaluating (+ 4 5) would result in the following process:

```
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

As we can see from the outlined model, this procedure results in a recursive process.

2. Given the following procedure,
```
(define (+ a b)
    (if (= a 0)
        b
        (+ (dec a) (inc b))))
```

evaluating (+ 4 5) would result in the following process:

> (+ 4 5)
> (+ 3 6)
> (+ 2 7)
> (+ 1 8)
> (+ 0 9)
> 9

As we can see, this procedure results in an iteratie process.

## 1.10

Given Ackermann's function:
```
(define (A x y)
    (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
```

Compute the values of the following expressions.

1. `(A 1 10)`
    Using substitution we can model the process as:
    
    ```
    (A 1 10)
    (A 0 (A 1 9))
    (A 0 (A 0 (A 1 8)))
    (A 0 (A 0 (A 0 (A 1 7))))
    (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
    (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
    (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
    (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
    (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
    (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
    (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
    (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
    (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
    (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
    (A 0 (A 0 (A 0 (A 0 (A 0 32)))))
    (A 0 (A 0 (A 0 (A 0 64))))
    (A 0 (A 0 (A 0 128)))
    (A 0 (A 0 512))
    (A 0 1024)
    2048
    ```

    This means that Ackermann's function is acting as 2^y when x = 1.

1. `(A 2 4)`
    We observe the following process for this procedure:

    ```
    (A 2 4)
    (A 1 (A 2 3))
    (A 1 (A 1 (A 2 2)))
    (A 1 (A 1 (A 1 (A 2 1))))
    (A 1 (A 1 (A 1 2)))
    (A 1 (A 1 (A 0 (A 1 1))))
    (A 1 (A 1 (A 0 2)))
    (A 1 (A 1 4))
    (A 1 (A 0 (A 1 3)))
    (A 1 (A 0 (A 0 (A 1 2))))
    (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
    (A 1 (A 0 (A 0 (A 0 2))))
    (A 1 (A 0 (A 0 4)))
    (A 1 (A 0 8))
    (A 1 16)
    ...
    65536
    ```

    We can substitute the last procedure call (A 1 16) with th calculation that was determined in the previous problem (A = 2^y when x = 1).

    Based on the process of the procedure with these parameters we can determine that A x y = 2^x^y.


1. `(A 3 3)`
    Using substitution again let's inspect the following process:

    ```
    (A 3 3)
    (A 2 (A 3 2))
    (A 2 (A 2 (A 3 1)))
    (A 2 (A 2 2))
    (A 2 (A 1 (A 2 1)))
    (A 2 (A 1 2))
    (A 2 (A 1 (A 0 1)))
    (A 2 (A 1 2))
    (A 2 (A 0 (A 1 1)))
    (A 2 (A 0 2))
    (A 2 4)
    ...
    65536
    ```

    This scenario contradicts our previous assumption that the algorithm could be defined as A x y = 2^x^y because 2^3^3 equals 134,217,728

Give the concise mathematical definitions for the following functions
1. `(define (f n) (A 0 n))`
    Looking at the implementation of the A procedure we can determine that the function f can be expressed as `f(n) = 2n`
1. `(define (g n ) (A 1 n))`
    Looking at the implementation of the A procedure and the process model of (A 1 10) we can say that g can be expressed as `g(n) = 0 for n = 0; 2^n for n > 0`
1. `(define (h n) (A 2 n))`
    Based on the process model of the (A 2 4) we can express h as `h(n) = 0 for n = 0; 2 for n = 1; 2^2^n for n > 1`
